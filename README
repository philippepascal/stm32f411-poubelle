# Install stable Rust if you don't already have it
curl https://sh.rustup.rs -sSf | sh

# Add the Cortex-M bare-metal target
rustup target add thumbv7em-none-eabi
#thumbv7em = Cortex-M4/M7 with floating point instructions available
#none = no OS
#eabi = ARM embedded ABI
#The F411 is an M4F, so that’s the right one.

rustup component add llvm-tools-preview
cargo install cargo-binutils

cargo new stm32f411-poubelle --bin

brew install arm-none-eabi-gcc openocd
brew install arm-none-eabi-binutils
brew install dfu-util

dfu-util -l

//after cargo build --release
cp target/thumbv7em-none-eabihf/release/build/cortex-m-rt-*/out/link.x link.x
// edit link.x to reduce flash size despite ram use

----------------------------------------------------------------
on the STM32F411 you have quite a few EXTI-capable pins, but only 16 interrupt lines (EXTI0–EXTI15).
Each line is shared across all GPIO ports (so PA0 and PB0 both map to EXTI0).
You can have up to 16 concurrent interrupts, one per EXTI line number.

You’re already using:
	•	PA7 → EXTI9_5 (lines 5–9 group)
	•	PA15 → EXTI15_10 (lines 10–15 group)

So lines 7 and 15 are taken.

You can safely add two more on any other unused EXTI line numbers (0–6, 8–14 except 7 and 15).
For example, on your STM32F411 “Black Pill” you might use:
Pin
EXTI Line
IRQ Vector
Notes
PA0     0   EXTI0   Currently used for DIR → not suitable unless re-routed
PA1     1   EXTI1   Currently used for STEP → not suitable
PA2     2   EXTI2   Free (good choice)
PA3     3   EXTI3   Free (good choice)
PA4     4   EXTI4   Free
PA5     5   EXTI9_5 Shares vector with PA7, but you can handle both in the same handler
PA8–PA9 8–9 EXTI9_5 Same group as PA7, shared vector
PA10–PA14   10–14   EXTI15_10   Shares vector with PA15

	If you want completely separate handlers (cleanest):
	•	PA2 → EXTI2 IRQ
	•	PA3 → EXTI3 IRQ
	•	If you don’t mind shared handlers (multiple pins per vector):
	•	You can use PA8 or PA9 (shared with PA7’s EXTI9_5).
	•	Or PA10–PA14 (shared with PA15’s EXTI15_10).

So for two more distinct interrupts, the simplest and least-conflicting choices are PA2 and PA3.
----------------------------------------------------------------

STM32 Pin			Connects To		Purpose
3.3V				VL53L1X VCC		Power
GND					VL53L1X GND		Ground
PB8					VL53L1X SCL		I²C Clock
PB9					VL53L1X SDA		I²C Data
PB0					Sensor 1 XSHUT	Reset / Address assignment
PB1					Sensor 2 XSHUT	Reset / Address assignment
PB5					Sensor 1 GPIO1	Interrupt output to detect motion, share EXTI9_5 with PA7 (button)
PB6					Sensor 2 GPIO1	Interrupt output to detect motion, share EXTI9_5 with PA7 (button)

PB8/PB9 are I2C1 on STM32F411.

By default, both sensors power up with the same I²C address (0x29).

To use them simultaneously on the same I²C bus:
	1.	Connect both to the same SDA/SCL/I2C bus.
	2.	Tie each XSHUT pin to a different GPIO (e.g., PA4 and PA5).
	3.	At startup:
	•	Drive both XSHUT pins LOW (reset state).
	•	Bring sensor 1 XSHUT HIGH, initialize it, change its I²C address.
	•	Bring sensor 2 XSHUT HIGH, initialize it, assign a different I²C address.

This way both coexist on one I2C bus.

 Important Electrical Notes
	•	Pull-up resistors (2.2k–4.7k) on SDA/SCL required — most breakout boards include them.
	•	Logic is 3.3V compatible (VL53L1X is 3.3V native).
	•	XSHUT pin is active LOW — pull LOW to reset/disable sensor.

⸻

✅ What You’ll Get Next in Code (When Ready)
	•	I²C initialization via stm32f4xx-hal.
	•	Sensor startup sequence + address reassignment.
	•	Non-blocking ranging in its own RTIC task.
	•	Instead of button event → trigger manual_opening.

----------------------------------------------------------------